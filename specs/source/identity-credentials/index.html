<!DOCTYPE html>
<html>
  <head>
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Identity Credentials 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <link rel="stylesheet" href="spec.css">
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='../common/common.js' class='remove'></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "identity-credentials",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: opencreds.localBiblio,

        issueBase: "https://github.com/opencreds/website/issues/",
        githubAPI: "https://api.github.com/repos/opencreds/website",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "http://opencreds.org/specs/source/identity-credentials/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors:  [
          { name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/"}
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:  [
            { name: "Manu Sporny", url: "http://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
            { name: "Dave Longley", url: "http://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/"}
        ],

        // name of the WG
        wg:           "W3C Credentials Community Group",

        // URI of the public WG page
        wgURI:        "http://www.w3.org/community/credentials/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-credentials",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "",
        maxTocLevel: 4,
        otherLinks: [{
          key: "Version control",
          data: [{
            value: "Github Repository",
            href: "https://github.com/opencreds/website"
          }, {
            value: "Issues",
            href: "https://github.com/opencreds/website/issues"
          }]
        }],
        inlineCSS: true,
        issueBase: "https://github.com/w3c/csvw/issues/",
      };
    </script>
    <script type="text/javascript" class="remove">
      var oldonload = window.onload;
      window.onload = function() {
        if (oldonload) oldonload();
        prettyPrint();
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
An <a>identity</a> is a collection of attributes about an entity that
distinguish it from other entities. Entities are anything with distinct
existence, such as people, organizations, concepts, or devices. Some entities,
such as people, are multifaceted, having multiple identities that they present
to the world. People are often able to establish trust by demonstrating that
others have made valuable claims about their identities. One way of doing this
is by presenting a <a>credential</a>. A <a>credential</a> is a set of
<a>claims</a> made by an <a>entity</a> about an <a>identity</a>. A
<a>credential</a> may refer to a qualification, achievement, quality, or other
information about an <a>identity</a> such as a name, government ID, home
address, or university degree that typically indicates suitability.
      </p>
      <p>
This specification describes how to express a digital <a>identity</a> and a
collection of digital <a>credentials</a> that assert <a>claims</a> about that
<a>identity</a>. It also describes a set of mechanisms for issuing and
requesting <a>credentials</a>.
      </p>
    </section>

    <section id='sotd'>
      <p>
This is an experimental specification that is attempting to unify the
work performed in the Credentials Community Group, the Web Payments Community
Group, the Linked Data community, the WebID Community Group, and the Mozilla
Persona team. As such, the specification borrows a number of concepts from each
group. It attempts to synthesize these concepts into a comprehensive solution
that can be easily implemented and deployed by Web developers in order to help
foster a rich ecosystem of digital identities and credentials on the Web.
      </p>

      <p class="issue">
This spec hasn't been updated in many months and the work has evolved quite
a bit since then. An update will occur as soon as other supporting documents
are in order and time permits. -- 9/24/15
      </p>

      <p class="issue">
Add a section specifying how blank nodes or pseudonyms can be used for
self-signed and IdP-asserted credentials.
      </p>

      <p class="issue">
Add a security/privacy consideration section that clearly marks out that
a single key should not be used for authentication at all websites and
that specifies how a different CryptographicKeyCredential can be generated
and signed by an IdP for every new origin visited. Add a note that this
approach is only for presenting identities that contain attributes that
are asserted by self-signed or IdP-asserted credentials.

This section should also detail best practices for creating a number of
separate identities that aggregate credentials asserted by different third
parties that are intended to be linked. There should be no doubt that this
system is engineered to support many different identities per individual user.
      </p>

    <p class="issue">
Add a section about revocation that also includes privacy concerns (leakage
of credential use at particular consumers to issuers). Specify how
credentials may self-describe their revocation rules and how issuers may
either publish revocation status credentials that can be aggregated over time
or on demand by IdPs or how they can periodically resign previously issued
credentials with new revocation validity periods (and these credentials can
then be refetched by users, IdPs, or authorized value-add third party services).
    </p>

    <p class="issue">
Add a section on the conversion of certain credentials, by anonymizer services,
to short-lived bearer credentials. These bearer credentials allow information
to be asserted with a level of trust that is dependent upon the anonymizer
service (which may actually be the same issuer that issued a credential), but
can be used to help enhance privacy.
    </p>

    <p class="issue">
Add a section on the use of ephemeral keys for public terminal use.
    </p>

    </section>

    <section>
      <h2>Introduction</h2>
      <p>
An <a>identity</a> is a set of information that can be used to identify
a particular <a>entity</a>. Entities are anything with distinct existence,
such as a person, organization, concept, or device. We typically use
<a>credentials</a>, or claims made by others about our identities, to
authenticate ourselves and ultimately gain access to various services. For
example, we use email addresses to identify ourselves to online services,
driver's licenses to prove that we are capable of operating a motor vehicle,
university degrees to prove we are well-trained and knowledgeable, and
government-issued passports to travel between countries or to access financial
services. It is the goal of this specification to provide an easy, standard
way to express, issue, and consume identity credentials on the Web.
      </p>
      <p>
There are a number of desirable capabilities for credentials that have been
identified as requirements for this specification:
      </p>
      <ul>
        <li>
User-centric credentials; credentials are linked to identities, not paricular
Web sites or services. Holders control which credentials to use and when.
Credential consumers need only trust issuers, allowing holders to freely choose
and swap out the services they employ to help them manage and share their
credentials.
        </li>
        <li>
A standard, machine-readable data format for expressing identity credentials
that can be extended with minimal coordination.
        </li>
        <li>
Independent issuance, storage, and cryptographic verification of credentials.
        </li>
        <li>
A standard mechanism for requesting credentials.
        </li>
        <li>
The ability to revoke previously issued credentials.
        </li>
        <li>
Web Browser APIs for storing and consuming credentials.
        </li>
        <li>
Privacy-enhanced credentials; holders may share credentials without revealing
the identity of the credential consumer to identity providers or issuers.
        </li>
      </ul>
      <p>
In order to store the unbounded variety of attributes that could be claimed
in identity credentials, a simple but extensible data model is utilized.
The specification uses a data storage and expression approach called
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. It
is a way of expressing information on the Web that is both simple and
extensible. Specifically, the Linked Data technology used by this specification
is JSON-LD [[!JSON-LD]].
      </p>
    </section>

    <section>
      <h2>Terminology</h2>

      <div data-include="../common/terms.html"
        data-oninclude="restrictReferences">
      </div>

    </section>

    <section>
      <p class="issue">
Provide better introduction to expressing identity and credentials. Indicate
that credentials make assertions about identities, so we'll show an example
identity with credentials in it to demonstrate the data format for both
at once.
      </p>

      <p class="issue">
The following sections on identity were originally about differentiating
between how one accessed private vs. public data in the identity. Instead,
it should just be able minimum properties that must be present in an
identity document ("idp" URL) and then talk about how credentials can be
associated with an identity. It may be better to then indicate what services
are expected at an IdP and document query and storage that way. So steps
are: 1. this is what an identity document looks like, 2. one property that
must exist is "idp" URL, 3. following that URL must give a description of the
IdP and its available services such as its endpoints for querying and storage.
Put focus on storing/getting credentials.
      </p>

      <h2>The Identity</h2>
      <p>
An entity may have one or more identities associated with it. Each identity may
fall on a different part of the anonymity spectrum. As such, more anonymous
identities will use identifiers that contain no personally identifiable
information, and less anonymous ones may include pseudonyms. The creation of
identifiers for these identities is out of scope for this document, but they
are typically in the form of a long-lived <a>identity document</a> URL. For
example, <code>did:aceb7ec32r734rcb3217b23c</code> or
<code>https://example.com/identities/john</code> are examples of long-lived
<a>identity document</a> URLs.
      </p>

      <section>
        <h2>A Basic Identity</h2>
        <p>
A basic identity contains at least the type information for the identity.
        <dl>
        <dt><code>@context</code></dt>
        <dd>The value <code>https://w3id.org/identity/v1</code>, or an equivalent
JSON-LD Context [[!JSON-LD]] expressing the terminology necessary for the
expression of the data.</dd>
        <dt><code>type</code></dt>
        <dd>The value <code>Identity</code>. Note that this field usually
contains more specific type information in addition to <code>Identity</code>
such as <code>Person</code> or <code>Organization</code>.</dd>
        </dl>
      </section>

      <section>
        <h2>A Typical Identity</h2>
        <p>
A typical identity will have a mix of public and private data associated with
it. For example:
        </p>

<pre class="example" title="A typical identity containing credentials">{
  "@context": "https://w3id.org/identity/v1",
  "id": "did:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["Identity", "Person"],
  "name": "Alice Bobman",
  "email": "alice@example.com",
  "birthDate": "1985-12-14",
  "telephone": "12345678910",
  "credential": [{
    "@graph": {
      "id": "http://example.com/credentials/1234",
      "type": ["Credential", "VerifiedEmailCredential"],
      "name": "Verified Email",
      "issuer": "https://example.com",
      "issued": "2010-01-01",
      "claim": {
        "id": "did:ebfeb1f712ebc6f1c276e12ec21",
        "email": "alice@example.com"
      },
      "signature": {
        "type": "LinkedDataSignature2015",
        "creator": "https://example.com/keys/2",
        "signature": "153eaabegeacesd35f34234dfdfevese2435343eve132r=="
      }
    }
  }, {
    "@graph": {
      "id": "http://example.gov/credentials/3732",
      "type": ["Credential", "PassportCredential"],
      "name": "Passport",
      "issuer": "https://example.gov",
      "issued": "2010-01-01",
      "claim": {
        "id": "did:ebfeb1f712ebc6f1c276e12ec21",
        "name": "Alice Bobman",
        "birthDate": "1985-12-14",
        "gender": "female",
        "nationality": {
          "name": "United States"
        },
        "address": {
          "type": "PostalAddress",
          "addressStreet": "372 Sumter Lane",
          "addressLocality": "Blackrock",
          "addressRegion": "Nevada",
          "postalCode": "237842",
          "addressCountry": "US"
        },
        "passport": {
          "type": "Passport",
          "name": "United States Passport",
          "documentId": "123-45-6789",
          "issuer": "https://example.gov",
          "issued": "2010-01-07T01:02:03Z",
          "expires": "2020-01-07T01:02:03Z"
        }
      },
      "signature": {
        "type": "LinkedDataSignature2015",
        "creator": "https://example.gov/keys/27",
        "signature": "3780eyfh3q0fhhfiq3q9f8ahsidfhf29rhaish"
      }
    }
  }, ... ]
}</pre>
       <p>
The example above contains a mix of public and private information. For example,
the <a>identity owner</a> may be comfortable with making their <code>name</code>
publicly readable and could do so using the <a>identity provider's</a> website
interface. Other information, such as that found in <code>credential</code>,
may be marked as private, and would only be shared after appropriate
authentication and authorization checks.
       </p>

      <p class="issue">
Indicate that how an IdP decides to do authorization is out-of-scope. All
that matters is that an identity URL can be query via HTTP to obtain its
IdP URL.
      </p>

       <p>
Information can be asserted, via a <a>credential</a>, by a third party and
stored with the identity using the mechanism described in
<a href="#storing-a-credential">Section 4: Storing a Credential</a>. Not all
information needs to be placed into a <a>credential</a>, only data asserted
by third parties whose authenticity can be verified via a digital-signature
needs to be expressed as a <a>credential</a>. For example,
<code>telephone</code> above is not in a <a>credential</a> as it is merely
self-asserted and its authenticity cannot be independently, cryptographically
verified. Other information, such as <code>name</code>, <code>birthDate</code>,
and <code>email</code> have been asserted via a <a>credential</a> by a third
party. In this particular case, two different credentials are shown, one
that indicates that the identity's email address has been verified by an
example company, and one that indicates that the identity's address and various
other information has been asserted by an example government.
       </p>
      </section>
    </section>
    <section>
      <h1>Requesting Identity Credentials</h1>
      <p>
There are two mechanisms that allow a third party to access an Identity's
credentials. The first is an HTTP Signature [[!HTTP-SIGNATURES]] based
mechanism that allows any authorized client to access credentials that have
been pre-approved by the entity that controls access to their identity
information. The second is to use a browser-based API that POSTs a request to
the identity owner's IdP, allowing the identity owner to interactively decide
which credentials to share.
      </p>

      <p class="issue">
        Add HTTP API information.
      </p>

<!--       <p>
The table below summarizes the HTTP Signatures-based [[!HTTP-SIGNATURES]]
mechanism of accessing and modifying an identity:
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">HTTP Method</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>GET</td>
            <td>
Read all of the information that is available to the <a>credential consumer</a>.
Note: This may only be a subset of all of the information based on the level
of access the <a>credential consumer</a> has to certain attributes in the resource.
            </td>
          </tr>
          <tr>
            <td>POST</td>
            <td>
Used to perform operations on the identity for applications that are not
capable of using HTTP Signatures [[!HTTP-SIGNATURES]] or to perform specific
queries on the identity data.
            </td>
          </tr>
          <tr>
            <td>PATCH</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]]
protocol.
            </td>
          </tr>
          <tr>
            <td>PUT</td>
            <td>
Replace the entire identity with the provided identity document. This operation
SHOULD only be accessible to the owner of the identity.
            </td>
          </tr>
          <tr>
            <td>DELETE</td>
            <td>
Deletes the identity. This operation SHOULD only be accessible to the owner of
the identity.
            </td>
          </tr>
        </tbody>
      </table>
-->
      <p class="issue" data-number="6"></p>

      <p>
Not every Web application is capable of prearranging access to credentials
or performing HTTP Signatures [[!HTTP-SIGNATURES]]. In these cases, a Web
Browser API is provided to store or get credentials from a holder.
      </p>

      <p class="issue">
        Add overview of extensions to Credential Management API 1.0.
      </p>

<!--      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">POST Parameter</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>action=query</td>
            <td>
Performs a query on the identity given a JSON-LD Frame in the POST body.
            </td>
          </tr>
          <tr>
            <td>action=patch</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]] protocol.
            </td>
          </tr>
        </tbody>
      </table>
-->

      <p class="issue">
Consider adding, to the new HTTP API section, a flow with 4xx Credentials
Required (if Authorization Required doesn't fit) with a response that includes
a location to get a credentials query, which when fulfilled via a POST to
an endpoint, will result in a macaroon. The macaroon can then be used to
access a resource or be attenuated and given out to delegate access.
      </p>

      <section>
        <h2>Reading Identity Information</h2>
        <p>
Reading identity information can be performed in 3 different ways depending on
the sensitivity of the information being accessed. An
<a>identity provider</a> SHOULD
ensure that sensitive information is always transmitted and received over a
secure channel, such as TLS [[!TLS]].
        </p>
        <p>
An identity can be accessed using a regular HTTP GET on the identity URL:
        </p>
        <pre class="example" title="An attempt to read all identity information without authentication">
GET /identities/alice HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:51:35 GMT
        </pre>
        <p>
If the <code>Content-Type</code> HTTP Header is not specified, a response using
the <code>application/ld+json</code> content type must be provided. Other
content types MAY be negotiated for between the client and server. The
<code>application/ld+json</code> content type is the only content type that
MUST be supported for all requests in this specification.
        </p>
        <p>
The result of the GET request SHOULD be information deemed to be public by the
<a>identity owner</a>:
        </p>
        <pre class="example" title="An example result when reading identity information without authentication">
{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith"
  "publicKey": [{ "id": "https://example.org/identities/alice/keys/1" }]
}
        </pre>
        <p>
As the response above shows, the only information that the
<a>identity owner</a> has specified as being public is their
<code>name</code> and a reference to their <code>publicKey</code>.
        </p>
        <p>
In order to access identity information that is not public, the request SHOULD
be authenticated and authorized against a known identity. The HTTP Signatures
[[!HTTP-SIGNATURES]] specification is used to digitally sign the request:
        </p>
        <pre class="example" title="An attempt to read all identity information with HTTP Signature-based authentication">
GET /identities/alice HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/ld+json
Authorization: Signature
  keyId="http://example.org/identities/bob/keys/4",
  algorithm="rsa-sha256",
  headers="(request-line) host date content-type",
  signature="Gm7W/r+e90REDpWyt.../VebAsNUtvQMe6cTjnDY="
        </pre>
<p>
The result of the GET request will now include information that the
<a>credential consumer</a> has been pre-authorized to read by the
<a>identity owner</a>:
        </p>
        <pre class="example" title="An example result when reading identity information with authentication">
{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith",
  "email": "asmith@example.com",
  "mobileNumber": "4424672637162",
  "publicKey": [{ "id": "https://example.org/identities/alice/keys/1" }]
}
        </pre>
        <p>
As the response above shows, in addition to the public information, the
<a>identity owner</a> has authorized the <a>credential consumer</a> to
access their <code>email</code> and <code>mobileNumber</code> as well.
        </p>
        <p>
In the event that the <a>credential consumer</a> has not authorized itself prior
to the request, or if it is not capable of performing an HTTP Signature
[[!HTTP-SIGNATURES]], it may utilize a POST-and-callback-based approach. The
following diagram provides an overview of how the POST-and-callback-based
approach works:

<img id="diagram-reading" alt="Basic Credential Flow"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
        </p>
        <p>
Once the <a>credential consumer</a> has tried to access a protected resource,
the website can request a particular set of credentials from the customer:
        </p>
        <pre class="example" title="A request to read citizenship information from an identity">
POST /query?credentials=true&amp;callback=https://flights.example.org/verify?session=7f8nddn HTTP/1.1
Host: login-hub.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "",
  "name": "",
  "governmentId": "",
  "birthdate": ""
}</pre>
        <p>
The result of the POST request will be a dialog that the
<a>identity provider</a> displays to the <a>identity owner</a>
asking them to verify the information that will be transmitted to the
<a>credential consumer</a>. The mechanism used to present this dialog to the
<a>identity owner</a> is outside of the scope of this specification.
The result of a successful interaction with the verification dialog will be
a POST back to the callback URL provided by the <a>credential consumer</a>:
        </p>
        <pre class="example" title="A successful response to an interactive request for citizenship information from an identity">
POST /verify?session=7f8nddn HTTP/1.1
Host: flights.example.org
Date: Tue, 07 Jun 2013 20:53:28 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith",
  "birthdate": "1988-11-02",
  "governmentId": "321-54-9876"
  "credential": [{
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "fhhfiq3q9f8ahfh3q029rhaishsidfhf3780ey"
    }
  }]
}
        </pre>
        <p>
As the response above shows, the <a>identity owner</a> accepted the
request for information and the <a>identity provider</a> has performed
a POST to the callback URL provided by the <a>credential consumer</a> via the
<a>identity owner's</a> web browser. Since the request included the
<code>credentials=true</code> flag, the credentials for the information
requested have been included so that the <a>credential consumer</a> may
validate the information against the third party credentials.
        </p>
      </section>

      <section>
        <h2>Credentials and Claims</h2>
        <p>
It is possible for a third party to provide digitally signed credentials to be
stored with an identity. For example, if an individual would like to store
digitally signed credentials verifiying their citizenship information, they
would go through the following process:
        </p>
        <ol>
          <li>Go to a government website and start the verification process.</li>
          <li>Provide their identity URL to the government website.</li>
          <li>The government website would digitally sign a credential and attempt to write it to the provided identity.</li>
          <li>The individual would be provided with a dialog to authorize the write of the credential to their identity.</li>
          <li>If the authorization is successful, the digitally signed credential is written to the identity and will be returned in future queries for such a credential.</li>
        </ol>
      </section>

      <section>
       <h2>Storing a credential</h2>
       <p class="issue">
Rewrite section to focus on storing credentials.
       </p>

       <p>
There are two mechanisms that allow a third party to write information
to an <a>identity document</a>. The first is an HTTP Signature
[[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to write data that has been pre-approved by the entity that controls
access to the identity information. The second is to use a browser-based
mechanism that POSTs a patch request to an <a>identity document</a>,
allowing the <a>identity owner</a> to interactively decide what data
to write to the <a>identity document</a>.
        </p>

        <p>
The example below demonstrates a digitally signed request to write information
to a specific <a>identity document</a> using an HTTP Signature:
        </p>

        <pre class="example" title="An attempt to write identity information using HTTP Signature-based authentication">
POST /identities/alice?action=patch HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
Authorization: Signature
  keyId="https://ssa.us.gov/keys/27",
  algorithm="rsa-sha256",
  headers="(request-line) host date content-type",
  signature="Gm7W/r+e90REDpWyt.../VebAsNUtvQMe6cTjnDY="

{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>

        <p>
The example below demonstrates an unsigned request to write information
to a specific <a>identity document</a>. Since the request is unsigned,
the <a>identity provider</a> would initiate an interactive authorization
where the <a>identity owner</a> would verify that the information to
be written is acceptable. The specifics of the interactive authorization flow
are outside the scope of this document, but are roughly outlined in the diagram
below:

<img id="diagram-writing" alt="Creating a Credential"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialCreation.svg">
        </p>

        <p>
The data that is sent back and forth is outlined below:
        </p>

        <pre class="example" title="An unsigned attempt to write identity information to an identity document">
POST /create?action=patch HTTP/1.1
Host: login-hub.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>
        <p>
The format for the message above is JSON-PATCH where the <code>path</code>
value is the complete URL for JSON-LD property to add to the
<a>identity document</a>.
        </p>
      </section>

    </section>

    <section>
      <h1>Web Credential-based Login</h1>
      <p>
It is possible to use the mechanism described in this specification to login to
a website in much the same way that Persona enables a verified email login. The
process is described below:
      </p>
      <ol>
        <li>
Go to a website that requires a valid email address for login.
        </li>
        <li>
The website requests the email address for login.
        </li>
        <li>
A document is fetched from the domain of the email address checking for a
Web Identity endpoint and identity service URL.
        </li>
        <li>
The user agent is instructed to retrieve the credential information from the
Web Identity endpoint and send it to the website requiring login.
        </li>
        <li>
The website that requires the valid email address for login checks the
credentials posted by the user agent, verifies the signatures, and creates a
session for the user.
        </li>
      </ol>

      <p>
The diagram below outlines the basic login flow described above.
<img id="diagram-login" alt="Basic Login Flow"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
      </p>

      <section>
        <h2>Detailed Flow for Credential-based Login</h2>
        <p class="issue" data-number="7"></p>
        <p>
In the following example, a login prompt is provided on
<code>store.example.org</code> where the person that is logging in provides
the <code>asmith@example.com</code> email address. The first step constitutes
<code>store.example.org</code> fetching the identity endpoint information
from <code>example.com</code>:
        </p>
        <pre class="example" title="Step 1a: Web Identity endpoint requested">
GET /.well-known/identity HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:42 GMT
Content-Type: application/ld+json
        </pre>
        <p>
A successful retrieval of the identity service endpoint will result in the
following document:
        </p>
        <pre class="example" title="Step 1b: Web Identity endpoint document retrieved">
HTTP/1.1 200 OK
Content-Type: application/ld+json
Content-Length: 34
Date: Wed, 08 Jun 2013 22:54:43 GMT

{
  "@context": "https://w3id.org/identity/v1",
  "identityService": "https://example.com/identities"
}
        </pre>
        <p>
The <code>store.example.org</code> software may then construct the proper query
to the identity service:
        </p>
        <pre class="example" title="Step 2a: Request verified e-mail information">
POST /identities?action=query&amp;credentials=true&amp;callback=https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:44 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "email": "asmith@example.com"
}
        </pre>
        <p>
After a UI interaction with Alice on <code>example.com</code> verifies that
the email information should be sent to <code>store.example.org</code>,
the following message is transmitted from Alice's user agent to
<code>store.example.org</code>:
        </p>
        <pre class="example" title="Step 2b: Request for e-mail information is fulfilled">
POST https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.org
Date: Wed, 08 Jun 2013 22:55:15 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.com/identities/asmith",
  "type": "Identity",
  "email": "asmith@example.com",
  "credential": [{
    "id": "http://example.com/credentials/23894",
    "type": "EmailCredential",
    "claim": {
      "id": "https://example.com/identities/asmith",
      "email": "asmith@example.com",
    },
    "expires": "2015-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://example.com/keys/24",
       "signature": "jf48901fu41...23908aszfhdk23h9f"
    }
  }]
}
        </pre>
        <p class="note">
Note that for the purposes of simplicity in the example above, there is
no tracking protection to prevent <code>example.com</code> from knowing which
website Alice is logging in to. Tracking protection is easily implemented by
adding a trusted third party, such as the browser UI or a third party mixer service,
that decouples the identity provider from the relying party.
        </p>
      </section>
    </section>

    <section>
      <h1>Compatibility with other Login Mechanisms</h1>
      <p>
This identity mechanism is designed to be compatible with other identity
mechanisms in use today such as OpenID, Facebook Connect, and Firefox ID.
      </p>
      <section>
        <h2>Integration with Mozilla Persona / Firefox ID</h2>
        <p>
The identity mechanism is such that it can be returned in a
Mozilla Persona or FxID-based login. The assertion returned to the FxID-enabled
website would contain an identity URL which would be compatible with this
specification. This allows both the basic email address to the validated, and
extension information (such as citizenship information, age assertions) to be
discoverable after the login.
        </p>
        <pre class="example" title="Example of a Mozilla Persona login assertion that also includes the identity URL of the entity">
{
  "public-key": {
    "algorithm": "DS",
    "y": "8e65e949e2e...1263ea6",
    "p": "ff600483dab...7fc26d0",
    "q": "e21e04f91d1...ecaab3b",
    "g": "c52a4a0ff34...233397a"
  },
  "principal": {
    "@context": "https://w3id.org/identity/v1",
    "email": "asmith@example.org",
    "identity": "https://example.org/identities/alice"   &lt;--- This bootstraps the identity assertion discovery process
  },
  "iat": 1392697368513,
  "exp": 1392783768513,
  "iss": "example.org"
}</pre>
     </section>

      <section>
        <h2>Integration with OpenID, OAuth1, and OAuth2</h2>
        <p class="issue" data-number="8"></p>
     </section>

    </section>
  </body>
</html>

