<!DOCTYPE html>
<html>
  <head>
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Identity Credentials 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <link rel="stylesheet" href="spec.css">
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='../common/common.js' class='remove'></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "identity-credentials",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: opencreds.localBiblio,

        issueBase: "https://github.com/opencreds/website/issues/",
        githubAPI: "https://api.github.com/repos/opencreds/website",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "http://opencreds.org/specs/source/identity-credentials/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors:  [
          { name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/"}
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:  [
            { name: "Manu Sporny", url: "http://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/" },
            { name: "Dave Longley", url: "http://digitalbazaar.com/",
              company: "Digital Bazaar, Inc.", companyURL: "http://digitalbazaar.com/"}
        ],

        // name of the WG
        wg:           "W3C Credentials Community Group",

        // URI of the public WG page
        wgURI:        "http://www.w3.org/community/credentials/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-credentials",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "",
        maxTocLevel: 4,
        otherLinks: [{
          key: "Version control",
          data: [{
            value: "Github Repository",
            href: "https://github.com/opencreds/website"
          }, {
            value: "Issues",
            href: "https://github.com/opencreds/website/issues"
          }]
        }],
        inlineCSS: true,
        issueBase: "https://github.com/w3c/csvw/issues/",
      };
    </script>
    <script type="text/javascript" class="remove">
      var oldonload = window.onload;
      window.onload = function() {
        if (oldonload) oldonload();
        prettyPrint();
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
An <em>identity</em> is a set of claims about an entity. Entities may be
anything with distinct existence, such as a person, organization, concept, or
device. Some entities, such as people, are multifaceted, having multiple
identities that they present to the world. People are often able to establish
trust by demonstrating that others have made valuable claims about their
identities. One way of doing this is by presenting a <em>credential</em>. A
<em>credential</em> is a set of claims made by one <em>identity</em> about
another <em>identity</em>. A <em>credential</em> may be a qualification,
achievement, quality, or other information about an entity such as a name,
government ID, home address, or university degree that typically indicates
suitability.
      </p>
      <p>
This specification describes how to express a digital identity and a collection
of digital credentials that assert claims about that identity. It also
describes a set of mechanisms for issuing, requesting, and securely reading
and writing credentials.
      </p>
    </section>

    <section id='sotd'>
      <p>
This is an experimental specification that is attempting to unify the
work performed in the the Web Payments Community Group,
the Linked Data community, the WebID Community Group,
and the Mozilla Persona team. As such, the specification borrows a number of
concepts from each group. It attempts to synthesize these concepts into a
comprehensive solution that can be easily implemented and deployed by Web
developers in order to help foster a rich ecosystem of digital identities and
credentials on the Web.
      </p>

      <p class="issue">
This spec hasn't been updated in many months and the work has evolved quite
a bit since then. An update will occur as soon as other supporting documents
are in order and time permits. -- 9/24/15
      </p>

      <p class="issue">
Add a section specifying how blank nodes or pseudonyms can be used for
self-signed and IdP-asserted credentials.
      </p>

      <p class="issue">
Add a security/privacy consideration section that clearly marks out that
a single key should not be used for authentication at all websites and
that specifies how a different CryptographicKeyCredential can be generated
and signed by an IdP for every new origin visited. Add a note that this
approach is only for presenting identities that contain attributes that
are asserted by self-signed or IdP-asserted credentials.

This section should also detail best practices for creating a number of
separate identities that aggregate credentials asserted by different third
parties that are intended to be linked. There should be no doubt that this
system is engineered to support many different identities per individual user.
      </p>

    <p class="issue">
Add a section about revocation that also includes privacy concerns (leakage
of credential use at particular consumers to issuers). Specify how
credentials may self-describe their revocation rules and how issuers may
either publish revocation status credentials that can be aggregated over time
or on demand by IdPs or how they can periodically resign previously issued
credentials with new revocation validity periods (and these credentials can
then be refetched by users, IdPs, or authorized value-add third party services).
    </p>

    <p class="issue">
Add a section on the conversion of certain credentials, by anonymizer services,
to short-lived bearer credentials. These bearer credentials allow information
to be asserted with a level of trust that is dependent upon the anonymizer
service (which may actually be the same issuer that issued a credential), but
can be used to help enhance privacy.
    </p>

    <p class="issue">
Add a section on the use of ephemeral keys for public terminal use.
    </p>

    </section>

    <section>
      <h2>Introduction</h2>
      <p>
An <a>identity</a> is a set of information that can be used to
identify a particular entity such as a person, software agent, animal, or
organization. We typically associate
<a>credentials</a> with identities to access many
services throughout our lives. For example, we use email addresses to identify
ourselves to online services, driver's licenses to prove that we are capable
of operating a motor vehicle, and government issued passports to travel
between countries. It is the goal of this specification to provide an easy
way of expressing all of this identity and credential information on the Web.
      </p>
      <p>
There are a number of design principles that have gone into the creation of
this specification. The following is a brief list of these requirements:
      </p>
      <ul>
        <li>
An identity and credentialing solution for the Web should be decentralized.
        </li>
        <li>
It must support discoverability by using a resolvable address, like a URL
or email address.
        </li>
        <li>
It must support, with authorization, arbitrary machine-readable information
being attached to the identity by third parties.
        </li>
        <li>
It must be able to provide both public and private data to external sites
based on who is accessing the resource.
        </li>
        <li>
The credential information must be protected by a secure digital signature
and encryption mechanism.
        </li>
      </ul>
      <p>
This specification enables secure, decentralized, discoverable, controlled
access to arbitrary machine-readable information associated with an identity.
Since it's useful to associate varying degrees of sensitive information
with a particular identity, the specification ensures that a single entity
can associate themselves with multiple identities. For example, one may want
to use one identity to access banking services while another identity
could be used to play online games.
      </p>
      <p>
In order to store the breadth of information that is typically associated with
an identity, a simple but extensible data model is utilized.
The specification uses a data storage and expression approach called
<a href="http://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. It
is a way of expressing information on the Web that is both simple and
extensible. Specifically, the Linked Data technology used by this specification
is JSON-LD [[!JSON-LD]].
      </p>
    </section>

    <section>
      <h2>Terminology</h2>

      <div data-include="../common/terms.html"
        data-oninclude="restrictReferences">
      </div>

    </section>

    <section>
      <h2>The Identity</h2>
      <p>
An entity may have one or more identities associated with it. These can be
anonymous identities, pseudo-anonymous identities, protected identities,
and public identities. The creation of these identities is out of scope
for this document, but typically result in the creation of a long-lived
<a>identity document</a> URL.
For example, <code>https://example.com/identities/john</code> is
an example of a long-lived <a>identity document</a> URL.
      </p>

      <section>
        <h2>A Basic Identity</h2>
        <p>
A basic identity contains at least the type information for the identity.
        <dl>
        <dt><code>@context</code></dt>
        <dd>The value <code>https://w3id.org/identity/v1</code>, or an equivalent
JSON-LD Context [[!JSON-LD]] expressing the terminology necessary for the
expression of the data.</dd>
        <dt><code>type</code></dt>
        <dd>The value <code>Identity</code>. Note that this field usually
contains more specific type information in addition to <code>Identity</code>
such as <code>Person</code> or <code>Organization</code>.</dd>
        </dl>
      </section>

      <section>
        <h2>A Typical Identity</h2>
        <p>
A typical identity will have a mix of public and private data associated with
it. For example:
        </p>

<pre class="example" title="A typical identity containing address and citizenship information">{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.com/identities/bob",
  "type": ["Identity", "Person"],
  "name": "Bob Bobman",
  "governmentId": "123-45-6789",
  "birthdate": "1985-12-14",
  "email": "bbob@example.com",
  "mobileNumber": "12345678910",
  "shippingAddress": {
    "street": "372 Sumter Lane",
    "city": "Blackrock",
    "region": "Nevada",
    "postalCode": "237842"
  },
  "credential": [{
    "id": "http://ssa.us.gov/credentials/3732",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.com/identities/bob",
      "name": "Bob Bobman",
      "birthdate": "1985-12-14",
      "governmentId": "123-45-6789"
    },
    "expires": "2018-01-01",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "3780eyfh3q0fhhfiq3q9f8ahsidfhf29rhaish"
    }
  }, ... ]
}</pre>
       <p>
The example above contains a mix of public and private information. For example,
the <a>identity owner</a> may be comfortable with making their
<code>name</code> publicly readable and would do so using the
<a>identity provider's</a> website interface.
Other information, such as <code>governmentId</code> and <code>email</code>
would be marked as private, and would only be shared after the request for
that particular information has been approved by the
<a>identity owner</a>.
       </p>
       <p>
Information can be asserted, via a <a>credential</a>, by a trusted
third party and written to the identity using the mechanism described in
<a href="#writing-data-to-the-identity">Section 4: Writing Data to
the Identity</a>. Not all information needs to be placed into a
<a>credential</a>. For example,
<code>shippingAddress</code> above is not in a <a>credential</a> and is
thus unverifiable. A <a>credential consumer</a> would have to trust that the
<code>shippingAddress</code> information provided
by the <a>identity owner</a> is trustworthy. Other information, such as
<code>name</code>, <code>birthdate</code>, and <code>governmentId</code>
have been asserted via a <a>credential</a> by a third party. In this
particular case, the information has been asserted by
the Social Security Administration of the United States government.
       </p>
      </section>
    </section>
    <section>
      <h1>Accessing the Identity</h1>
      <p>
There are two mechanisms that allow a third party to read protected information
from an identity. The first is an
HTTP Signature [[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to access data that has been pre-approved by the entity that controls
access to the identity information. The second is to use a browser-based
mechanism that POSTs a request to an identity, allowing the identity owner to
interactively decide what data access to allow or disallow.
      </p>

      <p>
The table below summarizes the HTTP Signatures-based [[!HTTP-SIGNATURES]]
mechanism of accessing and modifying an identity:
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">HTTP Method</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>GET</td>
            <td>
Read all of the information that is available to the <a>credential consumer</a>.
Note: This may only be a subset of all of the information based on the level
of access the <a>credential consumer</a> has to certain attributes in the resource.
            </td>
          </tr>
          <tr>
            <td>POST</td>
            <td>
Used to perform operations on the identity for applications that are not
capable of using HTTP Signatures [[!HTTP-SIGNATURES]] or to perform specific
queries on the identity data.
            </td>
          </tr>
          <tr>
            <td>PATCH</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]]
protocol.
            </td>
          </tr>
          <tr>
            <td>PUT</td>
            <td>
Replace the entire identity with the provided identity document. This operation
SHOULD only be accessible to the owner of the identity.
            </td>
          </tr>
          <tr>
            <td>DELETE</td>
            <td>
Deletes the identity. This operation SHOULD only be accessible to the owner of
the identity.
            </td>
          </tr>
        </tbody>
      </table>

      <p class="issue" data-number="6"></p>

      <p>
Not every Web application is capable of pre-arranging access to an identity,
performing HTTP Signatures [[!HTTP-SIGNATURES]], or executing
HTTP PATCH requests. In these cases, a regular HTTP POST mechanism is provided
for Web applications to read, write, and query information about the identity.
      </p>

      <table>
        <thead>
          <tr>
            <th style="white-space: nowrap;">POST Parameter</th>
            <th>Description of Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>action=query</td>
            <td>
Performs a query on the identity given a JSON-LD Frame in the POST body.
            </td>
          </tr>
          <tr>
            <td>action=patch</td>
            <td>
Modify information in the identity using the JSON Patch [[!JSON-PATCH]] protocol.
            </td>
          </tr>
        </tbody>
      </table>

      <section>
        <h2>Reading Identity Information</h2>
        <p>
Reading identity information can be performed in 3 different ways depending on
the sensitivity of the information being accessed. An
<a>identity provider</a> SHOULD
ensure that sensitive information is always transmitted and received over a
secure channel, such as TLS [[!TLS]].
        </p>
        <p>
An identity can be accessed using a regular HTTP GET on the identity URL:
        </p>
        <pre class="example" title="An attempt to read all identity information without authentication">
GET /identities/alice HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:51:35 GMT
        </pre>
        <p>
If the <code>Content-Type</code> HTTP Header is not specified, a response using
the <code>application/ld+json</code> content type must be provided. Other
content types MAY be negotiated for between the client and server. The
<code>application/ld+json</code> content type is the only content type that
MUST be supported for all requests in this specification.
        </p>
        <p>
The result of the GET request SHOULD be information deemed to be public by the
<a>identity owner</a>:
        </p>
        <pre class="example" title="An example result when reading identity information without authentication">
{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith"
  "publicKey": [{ "id": "https://example.org/identities/alice/keys/1" }]
}
        </pre>
        <p>
As the response above shows, the only information that the
<a>identity owner</a> has specified as being public is their
<code>name</code> and a reference to their <code>publicKey</code>.
        </p>
        <p>
In order to access identity information that is not public, the request SHOULD
be authenticated and authorized against a known identity. The HTTP Signatures
[[!HTTP-SIGNATURES]] specification is used to digitally sign the request:
        </p>
        <pre class="example" title="An attempt to read all identity information with HTTP Signature-based authentication">
GET /identities/alice HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/ld+json
Authorization: Signature
  keyId="http://example.org/identities/bob/keys/4",
  algorithm="rsa-sha256",
  headers="(request-line) host date content-type",
  signature="Gm7W/r+e90REDpWyt.../VebAsNUtvQMe6cTjnDY="
        </pre>
<p>
The result of the GET request will now include information that the
<a>credential consumer</a> has been pre-authorized to read by the
<a>identity owner</a>:
        </p>
        <pre class="example" title="An example result when reading identity information with authentication">
{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith",
  "email": "asmith@example.com",
  "mobileNumber": "4424672637162",
  "publicKey": [{ "id": "https://example.org/identities/alice/keys/1" }]
}
        </pre>
        <p>
As the response above shows, in addition to the public information, the
<a>identity owner</a> has authorized the <a>credential consumer</a> to
access their <code>email</code> and <code>mobileNumber</code> as well.
        </p>
        <p>
In the event that the <a>credential consumer</a> has not authorized itself prior
to the request, or if it is not capable of performing an HTTP Signature
[[!HTTP-SIGNATURES]], it may utilize a POST-and-callback-based approach. The
following diagram provides an overview of how the POST-and-callback-based
approach works:

<img id="diagram-reading" alt="Basic Credential Flow"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
        </p>
        <p>
Once the <a>credential consumer</a> has tried to access a protected resource,
the website can request a particular set of credentials from the customer:
        </p>
        <pre class="example" title="A request to read citizenship information from an identity">
POST /query?credentials=true&amp;callback=https://flights.example.org/verify?session=7f8nddn HTTP/1.1
Host: login-hub.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "",
  "name": "",
  "governmentId": "",
  "birthdate": ""
}</pre>
        <p>
The result of the POST request will be a dialog that the
<a>identity provider</a> displays to the <a>identity owner</a>
asking them to verify the information that will be transmitted to the
<a>credential consumer</a>. The mechanism used to present this dialog to the
<a>identity owner</a> is outside of the scope of this specification.
The result of a successful interaction with the verification dialog will be
a POST back to the callback URL provided by the <a>credential consumer</a>:
        </p>
        <pre class="example" title="A successful response to an interactive request for citizenship information from an identity">
POST /verify?session=7f8nddn HTTP/1.1
Host: flights.example.org
Date: Tue, 07 Jun 2013 20:53:28 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.org/identities/alice",
  "type": ["Identity", "Person"],
  "name": "Alice Smith",
  "birthdate": "1988-11-02",
  "governmentId": "321-54-9876"
  "credential": [{
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "fhhfiq3q9f8ahfh3q029rhaishsidfhf3780ey"
    }
  }]
}
        </pre>
        <p>
As the response above shows, the <a>identity owner</a> accepted the
request for information and the <a>identity provider</a> has performed
a POST to the callback URL provided by the <a>credential consumer</a> via the
<a>identity owner's</a> web browser. Since the request included the
<code>credentials=true</code> flag, the credentials for the information
requested have been included so that the <a>credential consumer</a> may
validate the information against the third party credentials.
        </p>
      </section>

      <section>
        <h2>Credentials and Claims</h2>
        <p>
It is possible for a third party to provide digitally signed credentials to be
stored with an identity. For example, if an individual would like to store
digitally signed credentials verifiying their citizenship information, they
would go through the following process:
        </p>
        <ol>
          <li>Go to a government website and start the verification process.</li>
          <li>Provide their identity URL to the government website.</li>
          <li>The government website would digitally sign a credential and attempt to write it to the provided identity.</li>
          <li>The individual would be provided with a dialog to authorize the write of the credential to their identity.</li>
          <li>If the authorization is successful, the digitally signed credential is written to the identity and will be returned in future queries for such a credential.</li>
        </ol>
      </section>

      <section>
       <h2>Writing Data to the Identity</h2>
       <p>
There are two mechanisms that allow a third party to write information
to an <a>identity document</a>. The first is an HTTP Signature
[[!HTTP-SIGNATURES]] based mechanism that allows any authorized
client to write data that has been pre-approved by the entity that controls
access to the identity information. The second is to use a browser-based
mechanism that POSTs a patch request to an <a>identity document</a>,
allowing the <a>identity owner</a> to interactively decide what data
to write to the <a>identity document</a>.
        </p>

        <p>
The example below demonstrates a digitally signed request to write information
to a specific <a>identity document</a> using an HTTP Signature:
        </p>

        <pre class="example" title="An attempt to write identity information using HTTP Signature-based authentication">
POST /identities/alice?action=patch HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
Authorization: Signature
  keyId="https://ssa.us.gov/keys/27",
  algorithm="rsa-sha256",
  headers="(request-line) host date content-type",
  signature="Gm7W/r+e90REDpWyt.../VebAsNUtvQMe6cTjnDY="

{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>

        <p>
The example below demonstrates an unsigned request to write information
to a specific <a>identity document</a>. Since the request is unsigned,
the <a>identity provider</a> would initiate an interactive authorization
where the <a>identity owner</a> would verify that the information to
be written is acceptable. The specifics of the interactive authorization flow
are outside the scope of this document, but are roughly outlined in the diagram
below:

<img id="diagram-writing" alt="Creating a Credential"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialCreation.svg">
        </p>

        <p>
The data that is sent back and forth is outlined below:
        </p>

        <pre class="example" title="An unsigned attempt to write identity information to an identity document">
POST /create?action=patch HTTP/1.1
Host: login-hub.com
Date: Tue, 07 Jun 2013 20:52:12 GMT
Content-Type: application/json-patch+json
{
  "op": "add",
  "path": "https://w3id.org/identity#credential",
  "value": {
    "@context": "https://w3id.org/identity/v1",
    "id": "http://ssa.us.gov/credential/8273",
    "type": "PassportCredential",
    "claim": {
      "id": "https://example.org/identities/alice",
      "name": "Alice Smith",
      "birthdate": "1988-11-02",
      "governmentId": "321-54-9876"
    },
    "expires": "2017-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://ssa.us.gov/keys/27",
       "signature": "r+e90REDpW....bAsNUtvQM"
    }
  }
}
        </pre>
        <p>
The format for the message above is JSON-PATCH where the <code>path</code>
value is the complete URL for JSON-LD property to add to the
<a>identity document</a>.
        </p>
      </section>

    </section>

    <section>
      <h1>Web Credential-based Login</h1>
      <p>
It is possible to use the mechanism described in this specification to login to
a website in much the same way that Persona enables a verified email login. The
process is described below:
      </p>
      <ol>
        <li>
Go to a website that requires a valid email address for login.
        </li>
        <li>
The website requests the email address for login.
        </li>
        <li>
A document is fetched from the domain of the email address checking for a
Web Identity endpoint and identity service URL.
        </li>
        <li>
The user agent is instructed to retrieve the credential information from the
Web Identity endpoint and send it to the website requiring login.
        </li>
        <li>
The website that requires the valid email address for login checks the
credentials posted by the user agent, verifies the signatures, and creates a
session for the user.
        </li>
      </ol>

      <p>
The diagram below outlines the basic login flow described above.
<img id="diagram-login" alt="Basic Login Flow"
  style="display: block; margin-left: auto; margin-right: auto;
  max-height:100%; max-width:50%;" src="basicCredentialFlow.svg">
      </p>

      <section>
        <h2>Detailed Flow for Credential-based Login</h2>
        <p class="issue" data-number="7"></p>
        <p>
In the following example, a login prompt is provided on
<code>store.example.org</code> where the person that is logging in provides
the <code>asmith@example.com</code> email address. The first step constitutes
<code>store.example.org</code> fetching the identity endpoint information
from <code>example.com</code>:
        </p>
        <pre class="example" title="Step 1a: Web Identity endpoint requested">
GET /.well-known/identity HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:42 GMT
Content-Type: application/ld+json
        </pre>
        <p>
A successful retrieval of the identity service endpoint will result in the
following document:
        </p>
        <pre class="example" title="Step 1b: Web Identity endpoint document retrieved">
HTTP/1.1 200 OK
Content-Type: application/ld+json
Content-Length: 34
Date: Wed, 08 Jun 2013 22:54:43 GMT

{
  "@context": "https://w3id.org/identity/v1",
  "identityService": "https://example.com/identities"
}
        </pre>
        <p>
The <code>store.example.org</code> software may then construct the proper query
to the identity service:
        </p>
        <pre class="example" title="Step 2a: Request verified e-mail information">
POST /identities?action=query&amp;credentials=true&amp;callback=https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.com
Date: Wed, 08 Jun 2013 22:54:44 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "email": "asmith@example.com"
}
        </pre>
        <p>
After a UI interaction with Alice on <code>example.com</code> verifies that
the email information should be sent to <code>store.example.org</code>,
the following message is transmitted from Alice's user agent to
<code>store.example.org</code>:
        </p>
        <pre class="example" title="Step 2b: Request for e-mail information is fulfilled">
POST https://store.example.org/verify?session=8d73j320s HTTP/1.1
Host: example.org
Date: Wed, 08 Jun 2013 22:55:15 GMT
Content-Type: application/ld+json

{
  "@context": "https://w3id.org/identity/v1",
  "id": "https://example.com/identities/asmith",
  "type": "Identity",
  "email": "asmith@example.com",
  "credential": [{
    "id": "http://example.com/credentials/23894",
    "type": "EmailCredential",
    "claim": {
      "id": "https://example.com/identities/asmith",
      "email": "asmith@example.com",
    },
    "expires": "2015-02-04",
    "signature": {
       "type": "GraphSignature2012",
       "creator": "https://example.com/keys/24",
       "signature": "jf48901fu41...23908aszfhdk23h9f"
    }
  }]
}
        </pre>
        <p class="note">
Note that for the purposes of simplicity in the example above, there is
no tracking protection to prevent <code>example.com</code> from knowing which
website Alice is logging in to. Tracking protection is easily implemented by
adding a trusted third party, such as the browser UI or a third party mixer service,
that decouples the identity provider from the relying party.
        </p>
      </section>
    </section>

    <section>
      <h1>Compatibility with other Login Mechanisms</h1>
      <p>
This identity mechanism is designed to be compatible with other identity
mechanisms in use today such as OpenID, Facebook Connect, and Firefox ID.
      </p>
      <section>
        <h2>Integration with Mozilla Persona / Firefox ID</h2>
        <p>
The identity mechanism is such that it can be returned in a
Mozilla Persona or FxID-based login. The assertion returned to the FxID-enabled
website would contain an identity URL which would be compatible with this
specification. This allows both the basic email address to the validated, and
extension information (such as citizenship information, age assertions) to be
discoverable after the login.
        </p>
        <pre class="example" title="Example of a Mozilla Persona login assertion that also includes the identity URL of the entity">
{
  "public-key": {
    "algorithm": "DS",
    "y": "8e65e949e2e...1263ea6",
    "p": "ff600483dab...7fc26d0",
    "q": "e21e04f91d1...ecaab3b",
    "g": "c52a4a0ff34...233397a"
  },
  "principal": {
    "@context": "https://w3id.org/identity/v1",
    "email": "asmith@example.org",
    "identity": "https://example.org/identities/alice"   &lt;--- This bootstraps the identity assertion discovery process
  },
  "iat": 1392697368513,
  "exp": 1392783768513,
  "iss": "example.org"
}</pre>
     </section>

      <section>
        <h2>Integration with OpenID, OAuth1, and OAuth2</h2>
        <p class="issue" data-number="8"></p>
     </section>

    </section>
  </body>
</html>

